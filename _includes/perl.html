<h2>Background</h2>

<p><a href="https://github.com/cognitect/transit-format">Transit</a> is a format layered on top of JSON and MessagePack, which provides richer types some simple compression for repeated values. There are implementations in several languages, so interacting with these will immediately become easier when adding a new language. My current company works primarily in Perl, so I decided to put an implementation up on <a href="https://metacpan.org/pod/Data::Transit">CPAN</a>.</p>

<h2>Reader Implementation</h2>

<p>There were a couple design tradeoffs that needed to be made while building this library. The first is that Transit allows for different types to be hash keys, but perl uses strings exclusively there. The second is that many native types have CPAN libraries but are not in core perl.</p>

<pre><code class="perl">package Data::Transit::Reader;
use JSON;

sub new {
	my ($class, %args) = @_;
	return bless {
		%args,
		cache => [],
		cache_counter => 0,
	}, $class;
}

sub read {
	my ($self, $json) = @_;
	return $self->_convert($self->_decode($json));
}

sub _convert_from_cached {
	my ($self, $data) = @_;
	return $self->_convert($self->_cache($data, 1));
}

sub _cache {
	my ($self, $data, $cacheable) = @_;
	return $self->{cache}[$1] if $data =~ /^\^(\d+)$/;
	$self->{cache}->[$self->{cache_counter}++] = $data if length($data) > 3 && $cacheable;
	return $data;
}

sub _convert {
	my ($self, $json) = @_;
	if (ref($json) eq 'ARRAY') {
		return $self->_convert($json->[1]) if $json->[0] eq "~#'";

		if ($self->_cache($json->[0], $json->[0] =~ /^~#/) =~ /^~#(.+)$/) {
			return $self->{handlers}{$1}->fromRep(@$json[1..$#$json]);
		}

		return $self->_convert_map($json) if $json->[0] eq "^ ";
		return [map {$self->_convert($_)} @$json];
	} else {
		return "" if $json eq "~_";
		return $json ? 1 : 0 if JSON::is_bool($json);
		return 1 if $json eq "~?t";
		return 0 if $json eq "~?f";
		return $1 if $json =~ /^~.(.+)$/;
		return $json;
	}
}

sub _convert_map {
	my ($self, $map) = @_;
	my %map = @$map[1..$#$map];
	return {map {$self->_convert_from_cached($_) => $self->_convert($map{$_})} keys %map};
}

1;</code></pre>
