<html>
	<head>
		<title>Colin Williams - Resume</title>
		<script src="http://code.jquery.com/jquery-1.11.2.min.js"></script>
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
		<link rel="stylesheet" href="/resources/styles.css">
		<link rel="stylesheet" href="/resources/highlight.css">
		<script src="/resources/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>
	<body>
		<nav class="navbar navbar-fixed-top navbar-default">
			<div class="container-fluid">
				<div class="navbar-header">
					<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#header">
						<span class="sr-only">Toggle navigation</span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</button>
					<a class="navbar-brand" href="#"><b class="text-primary">Colin Williams</b></a>
				</div>

				<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
					<ul class="nav navbar-nav">
						<li class="dropdown">
							<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Contact <span class="caret"></span></a>
							<ul class="dropdown-menu" role="menu">
								
									<li><a href="mailto:colin@colinwilliams.name"><b>Email</b> <span class="contact">colin@colinwilliams.name</span></a></li>
								
									<li><a href="http://resume.colinwilliams.name/"><b>Resume</b> <span class="contact">resume.colinwilliams.name</span></a></li>
								
									<li><a href="http://blog.colinwilliams.name/"><b>Blog</b> <span class="contact">blog.colinwilliams.name</span></a></li>
								
									<li><a href="https://github.com/lackita"><b>GitHub</b> <span class="contact">lackita</span></a></li>
								
									<li><a href="https://twitter.com/lackita101"><b>Twitter</b> <span class="contact">@lackita101</span></a></li>
								
							</ul>
						</li>
						<li class="active"><a href="#">Resume <span href="Colin_Williams.pdf" class="print glyphicon glyphicon-print"></span></a></li>
					</ul>
				</div>
			</div>
		</nav>

		<div class="container">
	<div class="row">
		<div class="col-xs-12">
			<div role="tabpanel">
				<ul class="nav nav-tabs" role="tablist">
					<li role="presentation" class="active"><a href="#java" role="tab" data-toggle="tab">Java</a></li>
					<li role="presentation"><a href="#clojure" role="tab" data-toggle="tab">Clojure</a></li>
					<li role="presentation"><a href="#python" role="tab" data-toggle="tab">Python</a></li>
					<li role="presentation"><a href="#ruby" role="tab" data-toggle="tab">Ruby</a></li>
					<li role="presentation"><a href="#perl" role="tab" data-toggle="tab">Perl</a></li>
				</ul>

				<div class="tab-content">
					<div role="tabpanel" class="tab-pane active" id="java">
						<pre><code class="java">package name.colinwilliams.dotcollision;

import java.awt.Point;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;

/* Being able to quickly look up dots proximity is a challenge.
 * An ArrayList would require O(n), but a hash lookup is difficult
 * because it works with discrete values.  To make this possible, we'll
 * divide the field into squares the same size as the dots, tracking all
 * of the dots that have any part in the square.  This limits lookup by
 * only having to consider dots that share a square. */
public class DotCollider implements Iterable<Dot> {
    private HashSet<Dot> dots;
    private HashMap<Point, HashSet<Dot>> grid;
    public DotCollider() {
	dots = new HashSet<Dot>();
	grid = new HashMap<Point, HashSet<Dot>>();
    }

    @Override
    public Iterator<Dot> iterator() {
	return dots.iterator();
    }

    public void add(Dot dot) {
	dots.add(dot);
	for (HashSet<Dot> covered_square : covered_squares(dot))
	    covered_square.add(dot);
    }

    public HashSet<Dot> dots_within(Dot dot) {
	HashSet<Dot> all_dots = new HashSet<Dot>();
	for (HashSet<Dot> dots_within_square : covered_squares(dot))
	    for (Dot overlap_candidate : dots_within_square)
		if (dot.overlaps(overlap_candidate))
		    all_dots.add(overlap_candidate);
	return all_dots;
    }

    public void update_location(Dot dot) {
	for (Point grid_box_corner : dot.previous_dot().square_corners_covering()) {
	    if (grid.containsKey(grid_box_corner)) grid.get(grid_box_corner).remove(dot);
	}
	add(dot);
    }

    private ArrayList<HashSet<Dot>> covered_squares(Dot dot) {
	ArrayList<HashSet<Dot>> result = new ArrayList<HashSet<Dot>>();
	for (Point corner : dot.square_corners_covering()) {
	    ensure_corner_exists(result, corner);
	    result.add(grid.get(corner));
	}
	return result;
    }

    private void ensure_corner_exists(ArrayList<HashSet<Dot>> result, Point corner) {
	if (!grid.containsKey(corner)) grid.put(corner, new HashSet<Dot>());
    }

    public Collection<Dot> get_collisions(Dot d) {
	ArrayList<Dot> collisions = new ArrayList<Dot>();
	for (Dot collided : dots_within(d)) {
	    if (d != collided)
		collisions.add(collided);
	}
	return collisions;
    }
}</code></pre>

					</div>
					<div role="tabpanel" class="tab-pane" id="clojure">
						<pre><code class="clojure">(defn negative [s]
  (symbol (.toLowerCase (name s))))

(defn positive [s]
  (symbol (.toUpperCase (name s))))

(defn gray-codes [symbols]
  (if (empty? symbols) [#{}]
      (let [varying (first symbols)
            subsequent-gray-codes (gray-codes (rest symbols))]
        (concat (map #(conj % (negative varying))
                     subsequent-gray-codes)
                (map #(conj % (positive varying))
                     (reverse subsequent-gray-codes))))))

(defn divide-symbols [symbols]
  (split-at (Math/ceil (/ (count symbols) 2)) symbols))

(defn build-grid [conditions x-gray-codes y-gray-codes]
  (map (fn [y-gray-code]
         (map #(if (conditions (set (concat % y-gray-code))) 1 0)
              x-gray-codes)) y-gray-codes))

(defn build-kmap [conditions]
  (let [[x-gray-codes y-gray-codes] (->> (first conditions)
                                         (map negative)
                                         sort
                                         divide-symbols
                                         (map gray-codes))
        grid (build-grid conditions x-gray-codes y-gray-codes)]
    {:grid grid
     :x-gray-codes x-gray-codes
     :y-gray-codes y-gray-codes
     :width (count (first grid))
     :height (count grid)}))


(defn gray-codes-for-box [gray-codes positions]
  (apply clojure.set/intersection
         (map #(nth gray-codes %) positions)))

(defn cyclic-ranges [distance size]
  (for [start (range distance)]
    (take size (drop start (cycle (range distance))))))

(defn rectangle-coordinates [kmap size]
  (set (for [divisor [1 2 4]
             xs (cyclic-ranges (kmap :width)
                               (/ size divisor))
             ys (cyclic-ranges (kmap :height)
                               divisor)]
         (set (for [x xs y ys] [x y])))))

(defn convert-pairs-to-expressions [kmap pairs]
  [(clojure.set/union
    (gray-codes-for-box (kmap :x-gray-codes)
                        (map first pairs))
    (gray-codes-for-box (kmap :y-gray-codes)
                        (map second pairs)))
   (set (map (fn [[x y]] (nth (nth (kmap :grid)
                                   y) x))
             pairs))])

(defn boxes-sized [kmap size]
  (set (map #(convert-pairs-to-expressions kmap %)
            (rectangle-coordinates kmap size))))

(defn identify-simplifications [kmap]
  (map (fn [size] (->> (boxes-sized kmap size)
                       (filter #(not (get-in % [1 0])))
                       (map first)))
       [8 4 2 1]))


(defn already-fulfilled? [existing-conditions new-condition]
  (not (some (fn [existing]
               (every? new-condition existing))
             existing-conditions)))

(defn prune-fulfilled [simplified-conditions]
  (set (reduce (fn [existing-conditions new-conditions]
                 (into existing-conditions
                       (filter #(already-fulfilled? existing-conditions %) new-conditions)))
               simplified-conditions)))

(defn identify-condition-coverage [full-conditions simplified-conditions]
  (into {} (map (fn [condition]
                  [condition (filter #(every? condition %)
                                     simplified-conditions)])
                full-conditions)))

(defn prune-duplicates [full-conditions simplified-conditions]
  (->> (prune-fulfilled simplified-conditions)
       (identify-condition-coverage full-conditions)
       (filter #(= (count (val %)) 1))
       (mapcat val)
       set))


(defn simplify-rules [conditions]
  (->> (build-kmap conditions)
       identify-simplifications
       (prune-duplicates conditions)))</code></pre>

					</div>
					<div role="tabpanel" class="tab-pane" id="python">
						Under Construction

					</div>
					<div role="tabpanel" class="tab-pane" id="ruby">
						<pre><code class="ruby">require 'taglib'

class Chapter < ActiveRecord::Base
  belongs_to :book
  has_attached_file :track
  after_find :update_audio_metadata

  def update_audio_metadata
    if self.track_file_name and not self.track_length
      TagLib::FileRef.open(track.path) do |mp3|
        self.track_length = mp3.audio_properties.length / 60
      end
    end
  end

  def displayed_track_length
    "#{track_length.to_i / 60}:#{(track_length.to_i % 60).to_s.rjust(2, padstr=0.to_s)}"
  end
end</code></pre>

					</div>
					<div role="tabpanel" class="tab-pane" id="perl">
						<pre><code class="perl">package Data::Transit::Reader;
use strict;
use warnings;
no warnings 'uninitialized';

our $VERSION = '0.8.01';

use JSON;

sub new {
	my ($class, %args) = @_;
	return bless {
		%args,
		cache => [],
		cache_counter => 0,
	}, $class;
}

sub read {
	my ($self, $json) = @_;
	return $self->_convert($self->_decode($json));
}

sub _convert_from_cached {
	my ($self, $data) = @_;
	return $self->_convert($self->_cache($data, 1));
}

sub _cache {
	my ($self, $data, $cacheable) = @_;
	return $self->{cache}[$1] if $data =~ /^\^(\d+)$/;
	$self->{cache}->[$self->{cache_counter}++] = $data if length($data) > 3 && $cacheable;
	return $data;
}

sub _convert {
	my ($self, $json) = @_;
	if (ref($json) eq 'ARRAY') {
		return $self->_convert($json->[1]) if $json->[0] eq "~#'";

		if ($self->_cache($json->[0], $json->[0] =~ /^~#/) =~ /^~#(.+)$/) {
			return $self->{handlers}{$1}->fromRep(@$json[1..$#$json]);
		}

		return $self->_convert_map($json) if $json->[0] eq "^ ";
		return [map {$self->_convert($_)} @$json];
	} else {
		return "" if $json eq "~_";
		return $json ? 1 : 0 if JSON::is_bool($json);
		return 1 if $json eq "~?t";
		return 0 if $json eq "~?f";
		return $1 if $json =~ /^~.(.+)$/;
		return $json;
	}
}

sub _convert_map {
	my ($self, $map) = @_;
	my %map = @$map[1..$#$map];
	return {map {$self->_convert_from_cached($_) => $self->_convert($map{$_})} keys %map};
}

1;</code></pre>

					</div>
				</div>
			</div>
		</div>
	</div>
</div>


		<script>
			$(document).ready(function () {
				$(".print").on("click", function() {
					window.location.href = "Colin_Williams.pdf";
					return false;
				});
			});
		</script>
	</body>
</html>
